<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Seed blog</title>
        <link>https://seedzz.abc/</link>
        <description>Welcome to my blog.</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 09 Jan 2023 04:27:56 &#43;0800</lastBuildDate>
            <atom:link href="https://seedzz.abc/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>我是如何对190平的家进行全屋组网的</title>
    <link>https://seedzz.abc/posts/assemble-my-family-network/</link>
    <pubDate>Mon, 09 Jan 2023 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/assemble-my-family-network/</guid>
    <description><![CDATA[因为家里的面积比较大，wifi信号一直覆盖的不好，刚好近期都在家里，所以借此重新把家里的网络调整了下，实现了全屋只有一个wifi，上网体验大幅度提升。因此写下这篇文章，来分享整个过程。
本文分两部分，第一部分先介绍现在普通家庭里大家是怎么上网的，第二部分则会介绍更合理的组网方案
家里普遍都是怎么上网的 光猫上网 现如今上网都是光纤到户，在运营商购买宽带后，会分配给你一个光猫，光猫插上光纤，浏览器登录其后台系统页面，输入运营商分配的账号密码后即可完常网络配置。
这时最简单的上网可以有两种方式，一种是电脑用网线插入到光猫的网线插口，但很显然现在都不是这么上网的。另一种则是采用wifi连接。
目前我们都是设备（手机、电脑、电视等等）连接wifi上网，有些光猫自身也携带了无线信号发射，只需在光猫的后台页面中设置好wifi的账号和密码后，我们的手机便可以连接该wifi来上网，用图来说就是这样的。
光猫+路由器上网 光猫作为wifi接入点，存在以下几个问题：
光猫硬件配置一般都比较低，当我们接入的设备比较多时，对光猫性能影响很大，势必也影响网速。 光猫的无线信号覆盖面积比较小，离光猫远的设备，网速影响较大，甚至可能出现无法搜索到wifi信号的情况。 大多数家庭的光猫都会放在弱电箱里，进而导致无线信号受到影响。 因此大多数家庭不会直接使用光猫作为wifi发射器使用，而是在光猫旁边配置一个路由器，由路由器来发射wifi无线信号，而且路由器功能也更加强大，除了有更多的天线来覆盖更大范围，其本身硬件配置也更高，还具备很多额外的wifi管理的功能（如设置2.4G和5.8G的网络等），用图来说就是这样。
接入过程如下：
将光纤插入到光猫的光纤插口，电脑登录光猫后台管理页面，配置好宽带的账号和密码。 将光猫的千兆口（往最高选没错）用网线连接到路由器的WAN口。WAN口，就是用来接入外部网路的端口，LAN口就是用来组合内部局域网的。这里的网线，最好买5类或者6类网线，毕竟现在都是wifi6的时代了，如果家里的网线比较久，建议直接换掉，否则可能影响带宽。 电脑登录路由器的后台管理页面，网络模式选择DHCP自动发现（即自动发现ip），简单理解，此时路由器便会直接使用光猫的网络，无需做额外上网账户的配置。 最后路由器设置好wifi的账号和密码，即可完成网络配置。 到这里，如果你的家是个两房一厅的小户型，五六十平米左右的，基本上wifi信号都已经足够覆盖，可能离路由器较远的房间，隔的墙比较多时，信号稍微有些弱，但是勉强也都能用。
光猫+路由器桥接 当家里的面积比较大时，单单只靠一个路由器，信号的覆盖面积有限，即使市面上有很多路由器宣称可以穿透几面墙，但是每穿透一面墙，信号就会大幅度衰减，这个事实是无法避免的。
那既然wifi信号会减弱，是不是可以在减弱的地方（例如房间）再加入一个或者多个路由器进行信号的桥接，将上一个路由器的wifi信号接入到下一个路由器中，达到信号逐渐传递的作用。显然，这是可以的，这种便是我们常说的无线接入点模式，即AP模式，目前主流的路由器都支持这种网络模式。
接入过程如下：
光猫接入路由器的过程，和之前的路程一致。 在信号弱的房间，放置一个新的路由器，登录路由器管理后台，网络模式选择无线桥接。这时路由器便会让你选择桥接哪个wifi信号，按步骤设置即可。 经过这种方式的网络布局后，手机里看到的无线信号都是满格了，然而这是一种假象。
光猫+交换机+路由器 * n 经过上面桥接后的网络，虽然信号看似正常，实则是一种假象。仔细想想，我们会在什么地方放置新的路由器来桥接无线网络，不就是在信号弱的地方。我们基于一个弱的信号来延长网络信号，即使可以使用类似信号放大器这样的硬件设施，但是信号也无法达到原信号的标准。
如果你的家里，已经有在各个房间预留好网络接口，则不建议这么来设置网络。
正因为如此，很多人也想到另一种方案，那如果我的各个房间都有网线接口，我是不是可以把路由器也放在这些房间，然后采用和弱电箱里与光猫连接的那个路由器相同的方式，来设置另一个wifi，我在客厅就连客厅的wifi，在房间就连房间的wifi。
例如家庭地址为A栋123号，客厅的wifi是弱电箱里的路由器配置的，则叫A#123，房间的wifi则叫A#123-room，有多个房间也可以通过序号来标明。
因此我们在新房装修的时候，便要记得在弱电箱里往各个房间拉好网线，在各个房间里装上网线接口，以方便我们后续根据需要，可以在房间直接插网线使用。
如图假设有4个房间，我们的弱电箱放在客厅的角落里，这时便可以在弱电箱里拉4条网线到各个房间里，此时你的房间应该就有这样的插座。
我们还需要使用一种新的硬件设备，交换机。你可以不用理解什么是交换机，只需要知道它能让插在它上面的设备都能上网即可，而且也比路由器便宜，一个千兆交换机也就百来块钱。
上图就是一个拥有5个接口的千兆交换机，需要接口根据需要购买即可，例如有4个房间，可以考虑买5个的。
先来看下网络接入图：
这里我们假设除了客厅，我们还需要在另外两个房间加新的路由器
接入的流程：
弱电箱里放了光猫、路由器和交换机，并且预埋好了通往各个房间的网线，并在房间里装好插口。 光猫配置好网络后，将其千兆口用网线插到交换机的一个接口，将路由器的WAN口用网线插到交换机的另一个接口。配置好路由器的wifi账号和密码，例如之前说的叫A#123。 将预埋好的各个房间的网线，在弱电箱这一头的插口插入到交换机的其余接口中。这时第一个路由器的配置就完成了，我们的设备便能搜索到第一个wifi信号A#123。 接下来我们去房间里放置新的路由器，同样将其WAN口和房间的网线插口连接，完成wifi账号和密码的设置即可，例如之前说的，叫A#123-room1，另一个房间的就叫A#123-room2。这样便完成了所有网络配置。 这里简单提一下为什么路由器的WAN口没有和光猫连接也能够上网。这就是交换机的作用了，咱们是把光猫和交换机用网线连接了，这样只要和交换机的其他接口连接的设备就都能上网了，而路由器的WAN口和交换机连接了，自然可以上网了。
经过这一系列网络配置后，我们在客厅就连接A#123，到了房间1则去连接A#123-room1，去房间2则去连接A#123-room2，wifi信号也不会减弱。
说到这里，我相信你也看出这种组网的问题了。我们从客厅走到房间，有时手机并不一定会自动帮你切换，我们就得手动选择。这种走到另一个区域就得切换wifi的方式，显然是非常繁琐的。咱们的宽带就一个，为什么不能只使用一个wifi信号来覆盖整个屋子。
全屋mesh组网 为什么选择mesh组网 前面章节的一系列组网方式，都是目前家庭常见的组网方式，这也是很多缺少网络知识的人的常见组网做法，这些做法都存在或多或少的缺陷，局限性非常大。
接下来我们就提供一种当前更加合理的组网方案。
要想实现全屋用一个wifi，目前常见的方式有两种：
AP组网，通过购买AP组网设备（不便宜）来进行组网，这种方式一般适用于大别墅多楼层的场景，费用比较高，一套做下来可能也得两千多。 mesh组网，也分为有线mesh组网和无线mesh组网，只需要购买能够支持mesh的路由器即可组网，一般便宜的一个也就两三百，一个150平左右的家庭，两个mesh路由器即可完成全屋覆盖。 AP组网和Mesh组网的区别：
mesh组网部署安装比较简单，有些设备甚至能够做到傻瓜式一插即用。而AP则相对复杂一些，需要有一定的网络专业背景知识。 mesh组网更加稳定，因为采用了主备路由器的方式，即使备用路由器发生故障，信息可以由其他路由器通过备用路径传送，不依赖于某一个单一节点的性能，所以比ap组网更加强健、更加稳定。 相对于ap组网而言，mesh组网可以选择经多个短跳来传输数据从而获得更高网络带宽，这也正是它的优势之一。 基于以上原因，我们这里选择mesh组网来搭建全屋wifi。
有线mesh组网流程 之前《光猫+路由器桥接》和《光猫+交换机+路由器的 * n》的章节中，都存在一个共同点，路由器都和光猫被绑定在一起。
光猫为了接入光纤，都会放在弱电箱，而弱电箱一般都会安置在客厅或者家里一个偏僻的角落，而路由器本身作为wifi信号发射器，却也和光猫被放置在这个角落里，导致wifi覆盖的范围不合理，甚至因为在弱电箱里的原因，信号刚发出，就被弱电箱的外壳隔档掉一部分。
路由器应该是放在能够最大可能覆盖wifi信号的区域，这正是我们这次组网的目的之一。
在mesh组网中，我们的路由器会有主路由和副路由之分。
主路由负责网络接入，也就是从光猫过来的网络接入，由主路由负责（当然，它也会发射wifi信号）。主路由就像之前介绍的一样，接入光猫后，只需要负责设置好wifi的账号和密码即可。主路由只有一个。 副路由则根据主路由的网络配置，发射相同的无线信号。副路由可以有多个，根据家庭面积分配即可。 基于以上这些不合理之处，我们的组网计划修改为如下：]]></description>
</item>
<item>
    <title>一文说透HTTP2</title>
    <link>https://seedzz.abc/posts/one-blog-to-know-http2/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/one-blog-to-know-http2/</guid>
    <description><![CDATA[1. HTTP的演进 1.1 HTTP/1 及其缺陷 众所周知，HTTP/1.0是HTTP协议的首个完整版本，它在协议中描述了我们常用的一些概念，例如首部（Header）、响应码（Status Code）、重定向（Redirect）、更多的方法（Post、Put、Delete等）。
而到了HTTP/1.1又带来了众多新的概念，例如缓存首部、OPTIONS方法、Upgrade首部、Range请求、管道化（Pipelining）、压缩和传输编码（transfer-encoing）。
然而随着Web越来越复杂，访问一个页面需要获取的资源越来越多，HTTP/1的一些缺陷也带来了性能上的问题。这里列举了几个比较重要的问题。
队头阻塞（Head-of-line blocking，或缩写为HOL blocking）
当我们的网站需要获取多份资源时（例如多张图片），HTTP/1协议下，如果只使用一个连接，则需要完成发起请求、等待响应这一对操作后，才可以发起下一次请求。在获取响应的过程中，一旦发生了任何问题，剩余的所有请求都会被阻塞住，此时页面也将无法渲染导致最终失去响应。
为了解决这种问题，浏览器一般都会开启多个连接来并发请求，然而每个连接依旧会受到“队头阻塞“的影响。
低效的TCP
我们知道TCP是一种可靠性非常高的通信协议，它通过滑动窗口和拥塞控制，保证了即使在最差的网络下数据也能的可靠的传输。其中有个非常重要的概念叫“慢启动”，它是用来探索当前连接对应拥塞窗口的大小，目的是用来让新的连接了解当前网络状况，避免给已经拥堵的网络继续添堵。
注：拥塞窗口指的是，在接收方确认接收到数据包前，发送方可以发送的包的数量。
然而这种方式虽然让网络避免了拥堵，却让通信的效率非常的低下。多次的数据往返才能确认最佳拥塞窗口，而且实际的实现中，遇到丢包的情况，拥塞算法通常会选择缩小拥塞窗口。甚至遇到超时时，甚至会重置拥塞窗口导致重新进入慢启动阶段。
首部臃肿
HTTP/1请求的首部是无法进行压缩的，现如今Web页面中加入的首部越来越多，大小也越来越多，无法压缩的首部也势必给通信效率带来不良的影响。
正因为HTTP/1存在的众多问题，社区上出现了很多针对性的优化，例如优化DNS查询、缓存机制、代码压缩、避免CSS/JS阻塞等。如果能从协议上去解决这些问题，才是问题最好的解决方式。
1.2 HTTP/2 HTTP/2的协议基础来源于Google提出的SPDY协议，SPDY提出的多路复用、帧和首部压缩这些功能，也被最终整合进了HTTP/2协议中。
HTTP/2包含如下几种特性：
多路复用，允许同时通过单一的HTTP/2连接发起多重的请求-响应信息，很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输 不再使用文本形式传输数据，而是采用二进制传输 首部压缩 服务器推送，改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。 2. 实现一个简单的HTTP/2服务 我们经常会搭建一些web服务用来提供一些http restful的api接口，通常使用的是HTTP/1.1的协议，是否也可以升级为HTTP/2呢？这里我们将以go语言搭建的http服务为例子，看看在go语言的场景下怎么实现一个HTTP/2的web服务。
2.1 TLS证书 HTTP/2协议中并没有要求必须使用TLS，然而当前主流的浏览器已都不支持非TLS的HTTP/2，也就是要求服务器端实现HTTPS。作为安全的角度，这也是合理的。
正因为如此，HTTP/2协议的握手分两种方式：
h2。这种握手方式下，要求必须使用TLS加密，在TLS握手期间会顺带完成HTTPS/2协议的协商，如果协商失败（比如客户端不支持或者服务端不支持），则会使用HTTPS/1继续后续通讯。 h2c。不使用TLS，而是多了一次基于HTTP协议的握手往返来完成向HTTP/2协议的升级，一般不建议使用 申请TLS证书的方式有很多。
可以自行采用openssl生成自签名证书 去Let&rsquo;s Encrypt中申请证书。 一些第三方网站也提供签发一些证书 作为实例，我们使用第一种方式生成我们的签名证书，这种证书只能用在本地调试使用，浏览器是无法认识的。
$ openssl genrsa -out key.pem 2048 $ openssl req -new -x509 -sha256 -key key.pem -out cert.pem -days 365 -subj &#34;/cn=demo.example.com&#34; 执行后，便拥有证书的私钥key.pem和对应的证书cert.pem。
2.2 实现HTTP2服务 go语言是原生支持HTTP/2的，当服务端使用TLS时，便会默认启用HTTP/2。
那么首先就来看下服务端的实例代码：]]></description>
</item>
<item>
    <title>从一个例子聊聊Go的接口</title>
    <link>https://seedzz.abc/posts/go-interface/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-interface/</guid>
    <description><![CDATA[一个有问题的案例 我们知道，go语言里，一个类型（例如结构体），在实现一个接口的时候，只需要其实现了这个接口里的所有方法，那么就算实现了该接口，而不需要像其他语言（例如java）一样显示的去声明实现某个接口。这种无侵入式的接口实现方式，也叫做“Duck typing”。
在接手一个项目时，曾遇到过这么一个问题，直接看代码
type Err struct { Code int32 Msg string } func (e *Err) Error() string { return fmt.Sprintf(&#34;[%d] %s&#34;, e.Code, e.Msg) } 从上述代码段能知道，以上Err结构体实现了error接口。
在项目代码中，存在这样的函数代码：
func someHandler() Err { ... } 虽然同样是返回错误，但是笔者觉得不是很优雅，于是在一次实现需求的时候，写了个类似这样的函数：
func someNewHandler() error { // do some thing ... var err *Err if badCase() { err = &amp;Err{Code: 5000, Msg:&#34;got error&#34;} return err } return err } 之后在调用该函数的时候，这么写到：
func Do() { err := someNewHandler() if err !]]></description>
</item>
<item>
    <title>基于Go语言的gRPC 使用指北</title>
    <link>https://seedzz.abc/posts/grpc-go-technology/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/grpc-go-technology/</guid>
    <description><![CDATA[1. grpc介绍 1.1 什么是grpc 在了解什么是grpc前，需要先知道什么是rpc。所谓的rpc（Remote Procedure Call），即远程过程的调用协议，我们也经常称为进程间通信协议，它可以让调用远程的函数像调用本地函数一样简单方便。
微服务和云原生架构出现后，我们构建一个系统时，各个业务功能都被拆分成了不同的服务模块，我们称之为微服务。而不同微服务间需要进行访问或者相互调用，便需要我们在不同微服务间定义统一的通信协议，构建一套进程间（或服务间）的通信技术来连接这些微服务。
我们常用的HTTP协议本身也是一种rpc协议，另外常见的rpc协议还有facebook的thrift和google的grpc，下面章节也会对比下这两种常见的协议和grpc的差别。
grpc是google于2015年开源的rpc框架，它具备标准化、可通用和跨平台的特点。这些特点使得不同微服务间可以方便的进行调用外，还支持可拓展的负载均衡、链路跟踪、健康检查等特性。而底层的通信，grpc采用的是HTTP/2来进行，性能和效率上能够得到充分的发挥。grpc也加入了CNCF（云原生计算基金会），逐渐的也成为了主流的社区上rpc框架。
grpc作为一门框架或者说协议，不同的编程语言（java、c++、python等）都可以基于这套协议标准进行实现，而grpc-go就是grpc在go语言下的实现，本文后面的所有例子也会采用它来做示例和讲解。
1.2 grpc与protocol buffers的关系 微服务间通信时，需要依赖统一的通信协议。这里我们暂且将主调方称为客户端，被调方称为服务端。
服务端需要先定义服务接口，这种服务接口的描述语言，我们便称之为接口定义语言（interface definition language，IDL），而protocol buffers便是grpc所使用的接口定义语言。
protocol buffers是一种语言中立、平台无关，用于实现结构化数据序列化的可扩展机制。根据该机制，服务接口将会定义一个文件扩展名为.proto的文件。如何使用protocol buffers不是本文的重点，具体可以参考官网 。
这里提供一个grpc官网给出的一个proto文件示例：
// The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user&#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } 我们通过proto文件定义好服务接口后，便需要根据这个定义生成服务端代码，我们称被生成的服务端代码为服务端骨架（skeleton）。]]></description>
</item>
<item>
    <title>深入理解Go Context</title>
    <link>https://seedzz.abc/posts/go-context/</link>
    <pubDate>Fri, 03 Jun 2022 12:21:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-context/</guid>
    <description><![CDATA[深入理解Go Context 什么是context？ 在go语言中，提供了context来为上下文建立联系，最常用的就是在不同协程调用间建立取消和超时机制，也可以用于传递相关值。
可以看下在go的源码中是如何描述context的。
A Context carries a deadline, a cancellation signal, and other values across 翻译过来，Context就是携带了超时时间、取消信号和值的一种结构。
如上图所述，举一个我们最常见的web开发为例子。在Go语言中，当客户端的请求进到服务器时，服务器端会开辟一个协程进行处理。有时在处理的过程中，我们还需要创建其他协程来进行其他的并发任务。为了能在多个协程间建立联系，便可以使用context。
在接收到请求后，创建一个context作为根context，当需要创建更多的协程时，则基于这个根context来创建子context，并且将根context的信息携带给子context。同理子context也可以创建更多的自己的子context给后续创建的协程。当其中有一个父协程处理超时，可以通知自己下面的所有子协程，这样这些子协程也不用再继续自己的任务，避免浪费资源和性能。
从图中可见，根context的第一个子context执行超时了，它后续的所有子context都能接收到context被取消的通知，进而取消自己的context。
深入context源码 在go中，提供了几种不同类型的context，他们都实现了context.Context接口。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline，返回context被取消的时间，当context没有设置取消时间时，ok则等于false； Done，会返回一个channel，这个channel会在任务完成或上下文被取消后关闭，多次调用会返回相同的channel； Err，会返回context结束的原因，在Done方法对应的channel还没关闭时，返回nil。在Done方法对应的channel已经关闭，返回非nil 如果context是被取消的，则返回Canceled错误 如果context是超时的，则返回DeadlineExceeded错误 Value，可以从context中获取key对应的值，可以用来在不同的context间传递数据； 接下来我们来看下go语言提供的几种context类型
context.Background和context.Todo 首先是context.Backgrouond和context.Todo，这两个context是我们最常用的context，两者其实都是返回的go中预先初始化好的context对象。
var ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo } 从源码中可以看到两者都是emptyCtx这个结构体的实例，而emptyCtx其实是Context接口的简单实现。]]></description>
</item>
</channel>
</rss>
