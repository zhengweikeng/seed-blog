<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>go - Tag - Seed blog</title>
        <link>https://seedzz.abc/tags/go/</link>
        <description>go - Tag - Seed blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</lastBuildDate><atom:link href="https://seedzz.abc/tags/go/" rel="self" type="application/rss+xml" /><item>
    <title>从一个例子聊聊Go的接口</title>
    <link>https://seedzz.abc/posts/go-interface/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-interface/</guid>
    <description><![CDATA[一个有问题的案例 我们知道，go语言里，一个类型（例如结构体），在实现一个接口的时候，只需要其实现了这个接口里的所有方法，那么就算实现了该接口，而不需要像其他语言（例如java）一样显示的去声明实现某个接口。这种无侵入式的接口实现方式，也叫做“Duck typing”。
在接手一个项目时，曾遇到过这么一个问题，直接看代码
type Err struct { Code int32 Msg string } func (e *Err) Error() string { return fmt.Sprintf(&#34;[%d] %s&#34;, e.Code, e.Msg) } 从上述代码段能知道，以上Err结构体实现了error接口。
在项目代码中，存在这样的函数代码：
func someHandler() Err { ... } 虽然同样是返回错误，但是笔者觉得不是很优雅，于是在一次实现需求的时候，写了个类似这样的函数：
func someNewHandler() error { // do some thing ... var err *Err if badCase() { err = &amp;Err{Code: 5000, Msg:&#34;got error&#34;} return err } return err } 之后在调用该函数的时候，这么写到：
func Do() { err := someNewHandler() if err !]]></description>
</item>
<item>
    <title>基于Go语言的gRPC 使用指北</title>
    <link>https://seedzz.abc/posts/grpc-go-technology/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/grpc-go-technology/</guid>
    <description><![CDATA[1. grpc介绍 1.1 什么是grpc 在了解什么是grpc前，需要先知道什么是rpc。所谓的rpc（Remote Procedure Call），即远程过程的调用协议，我们也经常称为进程间通信协议，它可以让调用远程的函数像调用本地函数一样简单方便。
微服务和云原生架构出现后，我们构建一个系统时，各个业务功能都被拆分成了不同的服务模块，我们称之为微服务。而不同微服务间需要进行访问或者相互调用，便需要我们在不同微服务间定义统一的通信协议，构建一套进程间（或服务间）的通信技术来连接这些微服务。
我们常用的HTTP协议本身也是一种rpc协议，另外常见的rpc协议还有facebook的thrift和google的grpc，下面章节也会对比下这两种常见的协议和grpc的差别。
grpc是google于2015年开源的rpc框架，它具备标准化、可通用和跨平台的特点。这些特点使得不同微服务间可以方便的进行调用外，还支持可拓展的负载均衡、链路跟踪、健康检查等特性。而底层的通信，grpc采用的是HTTP/2来进行，性能和效率上能够得到充分的发挥。grpc也加入了CNCF（云原生计算基金会），逐渐的也成为了主流的社区上rpc框架。
grpc作为一门框架或者说协议，不同的编程语言（java、c++、python等）都可以基于这套协议标准进行实现，而grpc-go就是grpc在go语言下的实现，本文后面的所有例子也会采用它来做示例和讲解。
1.2 grpc与protocol buffers的关系 微服务间通信时，需要依赖统一的通信协议。这里我们暂且将主调方称为客户端，被调方称为服务端。
服务端需要先定义服务接口，这种服务接口的描述语言，我们便称之为接口定义语言（interface definition language，IDL），而protocol buffers便是grpc所使用的接口定义语言。
protocol buffers是一种语言中立、平台无关，用于实现结构化数据序列化的可扩展机制。根据该机制，服务接口将会定义一个文件扩展名为.proto的文件。如何使用protocol buffers不是本文的重点，具体可以参考官网 。
这里提供一个grpc官网给出的一个proto文件示例：
// The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user&#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } 我们通过proto文件定义好服务接口后，便需要根据这个定义生成服务端代码，我们称被生成的服务端代码为服务端骨架（skeleton）。]]></description>
</item>
<item>
    <title>深入理解Go Context</title>
    <link>https://seedzz.abc/posts/go-context/</link>
    <pubDate>Fri, 03 Jun 2022 12:21:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-context/</guid>
    <description><![CDATA[深入理解Go Context 什么是context？ 在go语言中，提供了context来为上下文建立联系，最常用的就是在不同协程调用间建立取消和超时机制，也可以用于传递相关值。
可以看下在go的源码中是如何描述context的。
A Context carries a deadline, a cancellation signal, and other values across 翻译过来，Context就是携带了超时时间、取消信号和值的一种结构。
如上图所述，举一个我们最常见的web开发为例子。在Go语言中，当客户端的请求进到服务器时，服务器端会开辟一个协程进行处理。有时在处理的过程中，我们还需要创建其他协程来进行其他的并发任务。为了能在多个协程间建立联系，便可以使用context。
在接收到请求后，创建一个context作为根context，当需要创建更多的协程时，则基于这个根context来创建子context，并且将根context的信息携带给子context。同理子context也可以创建更多的自己的子context给后续创建的协程。当其中有一个父协程处理超时，可以通知自己下面的所有子协程，这样这些子协程也不用再继续自己的任务，避免浪费资源和性能。
从图中可见，根context的第一个子context执行超时了，它后续的所有子context都能接收到context被取消的通知，进而取消自己的context。
深入context源码 在go中，提供了几种不同类型的context，他们都实现了context.Context接口。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline，返回context被取消的时间，当context没有设置取消时间时，ok则等于false； Done，会返回一个channel，这个channel会在任务完成或上下文被取消后关闭，多次调用会返回相同的channel； Err，会返回context结束的原因，在Done方法对应的channel还没关闭时，返回nil。在Done方法对应的channel已经关闭，返回非nil 如果context是被取消的，则返回Canceled错误 如果context是超时的，则返回DeadlineExceeded错误 Value，可以从context中获取key对应的值，可以用来在不同的context间传递数据； 接下来我们来看下go语言提供的几种context类型
context.Background和context.Todo 首先是context.Backgrouond和context.Todo，这两个context是我们最常用的context，两者其实都是返回的go中预先初始化好的context对象。
var ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo } 从源码中可以看到两者都是emptyCtx这个结构体的实例，而emptyCtx其实是Context接口的简单实现。]]></description>
</item>
</channel>
</rss>
