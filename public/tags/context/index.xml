<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>context - Tag - Seed blog</title>
        <link>https://seedzz.abc/tags/context/</link>
        <description>context - Tag - Seed blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 03 Jun 2022 12:21:56 &#43;0800</lastBuildDate><atom:link href="https://seedzz.abc/tags/context/" rel="self" type="application/rss+xml" /><item>
    <title>深入理解Go Context</title>
    <link>https://seedzz.abc/posts/go-context/</link>
    <pubDate>Fri, 03 Jun 2022 12:21:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-context/</guid>
    <description><![CDATA[深入理解Go Context 什么是context？ 在go语言中，提供了context来为上下文建立联系，最常用的就是在不同协程调用间建立取消和超时机制，也可以用于传递相关值。
可以看下在go的源码中是如何描述context的。
A Context carries a deadline, a cancellation signal, and other values across 翻译过来，Context就是携带了超时时间、取消信号和值的一种结构。
如上图所述，举一个我们最常见的web开发为例子。在Go语言中，当客户端的请求进到服务器时，服务器端会开辟一个协程进行处理。有时在处理的过程中，我们还需要创建其他协程来进行其他的并发任务。为了能在多个协程间建立联系，便可以使用context。
在接收到请求后，创建一个context作为根context，当需要创建更多的协程时，则基于这个根context来创建子context，并且将根context的信息携带给子context。同理子context也可以创建更多的自己的子context给后续创建的协程。当其中有一个父协程处理超时，可以通知自己下面的所有子协程，这样这些子协程也不用再继续自己的任务，避免浪费资源和性能。
从图中可见，根context的第一个子context执行超时了，它后续的所有子context都能接收到context被取消的通知，进而取消自己的context。
深入context源码 在go中，提供了几种不同类型的context，他们都实现了context.Context接口。
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline，返回context被取消的时间，当context没有设置取消时间时，ok则等于false； Done，会返回一个channel，这个channel会在任务完成或上下文被取消后关闭，多次调用会返回相同的channel； Err，会返回context结束的原因，在Done方法对应的channel还没关闭时，返回nil。在Done方法对应的channel已经关闭，返回非nil 如果context是被取消的，则返回Canceled错误 如果context是超时的，则返回DeadlineExceeded错误 Value，可以从context中获取key对应的值，可以用来在不同的context间传递数据； 接下来我们来看下go语言提供的几种context类型
context.Background和context.Todo 首先是context.Backgrouond和context.Todo，这两个context是我们最常用的context，两者其实都是返回的go中预先初始化好的context对象。
var ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo } 从源码中可以看到两者都是emptyCtx这个结构体的实例，而emptyCtx其实是Context接口的简单实现。]]></description>
</item>
</channel>
</rss>
