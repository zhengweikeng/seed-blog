<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>interface - Tag - Seed blog</title>
        <link>https://seedzz.abc/tags/interface/</link>
        <description>interface - Tag - Seed blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</lastBuildDate><atom:link href="https://seedzz.abc/tags/interface/" rel="self" type="application/rss+xml" /><item>
    <title>从一个例子聊聊Go的接口</title>
    <link>https://seedzz.abc/posts/go-interface/</link>
    <pubDate>Sun, 03 Jul 2022 04:27:56 &#43;0800</pubDate>
    <author>Seed</author>
    <guid>https://seedzz.abc/posts/go-interface/</guid>
    <description><![CDATA[一个有问题的案例 我们知道，go语言里，一个类型（例如结构体），在实现一个接口的时候，只需要其实现了这个接口里的所有方法，那么就算实现了该接口，而不需要像其他语言（例如java）一样显示的去声明实现某个接口。这种无侵入式的接口实现方式，也叫做“Duck typing”。
在接手一个项目时，曾遇到过这么一个问题，直接看代码
type Err struct { Code int32 Msg string } func (e *Err) Error() string { return fmt.Sprintf(&#34;[%d] %s&#34;, e.Code, e.Msg) } 从上述代码段能知道，以上Err结构体实现了error接口。
在项目代码中，存在这样的函数代码：
func someHandler() Err { ... } 虽然同样是返回错误，但是笔者觉得不是很优雅，于是在一次实现需求的时候，写了个类似这样的函数：
func someNewHandler() error { // do some thing ... var err *Err if badCase() { err = &amp;Err{Code: 5000, Msg:&#34;got error&#34;} return err } return err } 之后在调用该函数的时候，这么写到：
func Do() { err := someNewHandler() if err !]]></description>
</item>
</channel>
</rss>
